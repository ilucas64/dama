<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo de Damas com IA</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
        }
        h1 {
            color: #333;
            margin-bottom: 10px;
        }
        canvas {
            border: 2px solid #333;
            background-color: #fff;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        #controls {
            margin: 20px;
            text-align: center;
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        button, select {
            padding: 10px 15px;
            margin: 5px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            background-color: #4CAF50;
            color: white;
            transition: background-color 0.3s;
        }
        button:hover, select:hover {
            background-color: #45a049;
        }
        #message {
            margin-top: 10px;
            font-size: 18px;
            color: #333;
            font-weight: bold;
            min-height: 24px;
        }
        #counters {
            display: flex;
            justify-content: space-around;
            width: 100%;
            max-width: 400px;
            margin-bottom: 15px;
        }
        .counter {
            background-color: #fff;
            padding: 10px 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        .counter span {
            font-weight: bold;
            color: #4CAF50;
        }
    </style>
</head>
<body>
    <h1>Jogo de Damas com IA</h1>
    
    <div id="counters">
        <div class="counter">Jogador: <span id="player-count">12</span></div>
        <div class="counter">IA: <span id="ia-count">12</span></div>
    </div>
    
    <canvas id="board" width="400" height="400"></canvas>
    
    <div id="controls">
        <select id="difficulty">
            <option value="easy">Fácil</option>
            <option value="medium">Médio</option>
            <option value="hard">Difícil</option>
        </select>
        <button onclick="startGame()">Iniciar Jogo</button>
        <div id="message">Selecione a dificuldade e inicie o jogo!</div>
    </div>

    <script>
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        const size = 8;
        const cellSize = canvas.width / size;
        let board = [];
        let selectedPiece = null;
        let currentPlayer = 'player';
        let difficulty = 'easy';
        let gameOver = false;
        let mustCapture = false;
        let captureChainPiece = null;

        // Inicializa o tabuleiro
        function initializeBoard() {
            board = Array(size).fill().map(() => Array(size).fill(null));
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    if ((row + col) % 2 === 1) {
                        if (row < 3) board[row][col] = { player: 'ia', isKing: false };
                        if (row > 4) board[row][col] = { player: 'player', isKing: false };
                    }
                }
            }
            updateCounters();
        }

        // Atualiza os contadores de peças
        function updateCounters() {
            let playerCount = 0;
            let iaCount = 0;
            
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    if (board[row][col]) {
                        if (board[row][col].player === 'player') playerCount++;
                        else iaCount++;
                    }
                }
            }
            
            document.getElementById('player-count').textContent = playerCount;
            document.getElementById('ia-count').textContent = iaCount;
        }

        // Desenha o tabuleiro
        function drawBoard() {
            if (!ctx) {
                console.error('Contexto do canvas não disponível');
                return;
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Desenha as células do tabuleiro
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    ctx.fillStyle = (row + col) % 2 === 0 ? '#f8f8f8' : '#8B4513';
                    ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
                    
                    const piece = board[row][col];
                    if (piece) {
                        // Desenha a peça
                        const centerX = (col + 0.5) * cellSize;
                        const centerY = (row + 0.5) * cellSize;
                        const radius = cellSize / 2 - 10;
                        
                        // Gradiente para efeito 3D
                        const gradient = ctx.createRadialGradient(
                            centerX - radius/3, centerY - radius/3, radius/4,
                            centerX, centerY, radius
                        );
                        
                        if (piece.player === 'player') {
                            gradient.addColorStop(0, '#ffffff');
                            gradient.addColorStop(1, '#cccccc');
                        } else {
                            gradient.addColorStop(0, '#333333');
                            gradient.addColorStop(1, '#000000');
                        }
                        
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                        ctx.fillStyle = gradient;
                        ctx.fill();
                        
                        // Desenha a coroa se for uma dama
                        if (piece.isKing) {
                            ctx.beginPath();
                            ctx.arc(centerX, centerY, radius/2, 0, Math.PI * 2);
                            ctx.fillStyle = piece.player === 'player' ? '#FFD700' : '#C0C0C0';
                            ctx.fill();
                            ctx.beginPath();
                            ctx.arc(centerX, centerY, radius/3, 0, Math.PI * 2);
                            ctx.fillStyle = piece.player === 'player' ? '#FFD700' : '#C0C0C0';
                            ctx.fill();
                        }
                    }
                }
            }
            
            // Destaca a peça selecionada
            if (selectedPiece) {
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 3;
                ctx.strokeRect(
                    selectedPiece.col * cellSize + 2, 
                    selectedPiece.row * cellSize + 2, 
                    cellSize - 4, 
                    cellSize - 4
                );
            }
        }

        // Inicia o jogo
        function startGame() {
            difficulty = document.getElementById('difficulty').value;
            initializeBoard();
            selectedPiece = null;
            currentPlayer = 'player';
            gameOver = false;
            mustCapture = false;
            captureChainPiece = null;
            document.getElementById('message').textContent = 'Sua vez!';
            drawBoard();
        }

        // Verifica movimentos válidos
        function getValidMoves(row, col, enforceCapture = false) {
            const piece = board[row][col];
            if (!piece) return [];
            
            const moves = [];
            const directions = [];
            
            // Define as direções baseado no tipo de peça
            if (piece.isKing) {
                // Dama pode se mover em todas as direções diagonais
                directions.push([-1, -1], [-1, 1], [1, -1], [1, 1]);
            } else {
                // Peça normal só se move para frente (relativo ao jogador)
                if (piece.player === 'player') {
                    directions.push([-1, -1], [-1, 1]);
                } else {
                    directions.push([1, -1], [1, 1]);
                }
            }
            
            let hasCaptures = false;
            
            // Verifica movimentos possíveis em cada direção
            for (const [dr, dc] of directions) {
                // Movimento simples (não-captura)
                let nr = row + dr, nc = col + dc;
                if (!enforceCapture && nr >= 0 && nr < size && nc >= 0 && nc < size && !board[nr][nc]) {
                    moves.push({ row: nr, col: nc, capture: false });
                }
                
                // Movimento de captura
                let jumpRow = row + 2 * dr, jumpCol = col + 2 * dc;
                if (jumpRow >= 0 && jumpRow < size && jumpCol >= 0 && jumpCol < size && 
                    board[nr][nc] && board[nr][nc].player !== piece.player && 
                    !board[jumpRow][jumpCol]) {
                    moves.push({ 
                        row: jumpRow, 
                        col: jumpCol, 
                        capture: true, 
                        captured: { row: nr, col: nc } 
                    });
                    hasCaptures = true;
                }
                
                // Movimentos adicionais para damas (múltiplas casas)
                if (piece.isKing) {
                    let cr = row + dr, cc = col + dc;
                    let foundEnemy = false;
                    
                    while (cr >= 0 && cr < size && cc >= 0 && cc < size) {
                        if (board[cr][cc]) {
                            if (board[cr][cc].player === piece.player) break; // Peça aliada bloqueia
                            if (foundEnemy) break; // Já encontrou uma peça inimiga
                            foundEnemy = true;
                            // Verifica se pode pular sobre a peça inimiga
                            const nextRow = cr + dr, nextCol = cc + dc;
                            if (nextRow >= 0 && nextRow < size && nextCol >= 0 && nextCol < size && 
                                !board[nextRow][nextCol]) {
                                moves.push({ 
                                    row: nextRow, 
                                    col: nextCol, 
                                    capture: true, 
                                    captured: { row: cr, col: cc } 
                                });
                                hasCaptures = true;
                            } else {
                                break;
                            }
                        } else if (!foundEnemy && !enforceCapture) {
                            moves.push({ row: cr, col: cc, capture: false });
                        }
                        cr += dr;
                        cc += dc;
                    }
                }
            }
            
            // Se houver capturas e for obrigatório capturar, retorna só as capturas
            return enforceCapture && hasCaptures ? moves.filter(move => move.capture) : moves;
        }

        // Verifica se há capturas obrigatórias
        function hasMandatoryCaptures(player, specificPiece = null) {
            if (specificPiece) {
                return getValidMoves(specificPiece.row, specificPiece.col, true).length > 0;
            }
            
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    if (board[row][col] && board[row][col].player === player) {
                        if (getValidMoves(row, col, true).length > 0) return true;
                    }
                }
            }
            return false;
        }

        // Executa um movimento
        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            if (!piece || toRow < 0 || toRow >= size || toCol < 0 || toCol >= size) return false;
            
            const moves = getValidMoves(fromRow, fromCol, mustCapture || captureChainPiece);
            const move = moves.find(m => m.row === toRow && m.col === toCol);
            if (!move) return false;
            
            // Move a peça
            board[toRow][toCol] = {...piece};
            board[fromRow][fromCol] = null;
            
            // Verifica se a peça se tornou uma dama
            if (!piece.isKing) {
                if ((piece.player === 'player' && toRow === 0) || 
                    (piece.player === 'ia' && toRow === size - 1)) {
                    board[toRow][toCol].isKing = true;
                }
            }
            
            let isCapture = false;
            
            // Processa captura se houver
            if (move.capture) {
                board[move.captured.row][move.captured.col] = null;
                isCapture = true;
            }
            
            updateCounters();
            return isCapture;
        }

        // Avalia o tabuleiro para a IA
        function evaluateBoard() {
            let score = 0;
            
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        // Valor base
                        let pieceValue = piece.isKing ? 3 : 1;
                        
                        // Bônus de posição (peças no centro são mais valiosas)
                        const centerDist = Math.abs(col - 3.5) + Math.abs(row - 3.5);
                        pieceValue += (7 - centerDist) * 0.1;
                        
                        // Bônus para peças avançadas (para o jogador)
                        if (piece.player === 'player') {
                            pieceValue += (7 - row) * 0.1;
                        } else {
                            pieceValue += row * 0.1;
                        }
                        
                        // Adiciona ao score total
                        score += piece.player === 'ia' ? pieceValue : -pieceValue;
                    }
                }
            }
            
            return score;
        }

        // Minimax com poda alfa-beta
        function minimax(depth, alpha, beta, isMaximizing, chainCapture = false, chainPiece = null) {
            if (depth === 0 || checkWin().winner) {
                return evaluateBoard();
            }
            
            const moves = getAllPossibleMoves(isMaximizing ? 'ia' : 'player', chainCapture ? chainPiece : null);
            
            if (isMaximizing) {
                let maxEval = -Infinity;
                for (const move of moves) {
                    const tempBoard = board.map(row => row.slice());
                    const isCapture = makeMove(move.fromRow, move.fromCol, move.toRow, move.toCol);
                    let evaluation;
                    
                    if (isCapture && getValidMoves(move.toRow, move.toCol, true).length > 0) {
                        evaluation = minimax(depth, alpha, beta, isMaximizing, true, { row: move.toRow, col: move.toCol });
                    } else {
                        evaluation = minimax(depth - 1, alpha, beta, false, false, null);
                    }
                    
                    board = tempBoard;
                    maxEval = Math.max(maxEval, evaluation);
                    alpha = Math.max(alpha, evaluation);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const move of moves) {
                    const tempBoard = board.map(row => row.slice());
                    const isCapture = makeMove(move.fromRow, move.fromCol, move.toRow, move.toCol);
                    let evaluation;
                    
                    if (isCapture && getValidMoves(move.toRow, move.toCol, true).length > 0) {
                        evaluation = minimax(depth, alpha, beta, isMaximizing, true, { row: move.toRow, col: move.toCol });
                    } else {
                        evaluation = minimax(depth - 1, alpha, beta, true, false, null);
                    }
                    
                    board = tempBoard;
                    minEval = Math.min(minEval, evaluation);
                    beta = Math.min(beta, evaluation);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }

        // Obtém todos os movimentos possíveis
        function getAllPossibleMoves(player, specificPiece = null) {
            const moves = [];
            const mustCapture = !specificPiece && hasMandatoryCaptures(player);
            const rows = specificPiece ? [specificPiece.row] : Array.from({ length: size }, (_, i) => i);
            const cols = specificPiece ? [specificPiece.col] : Array.from({ length: size }, (_, i) => i);
            
            for (const row of rows) {
                for (const col of cols) {
                    if (board[row][col] && board[row][col].player === player) {
                        const validMoves = getValidMoves(row, col, mustCapture || !!specificPiece);
                        for (const move of validMoves) {
                            moves.push({ 
                                fromRow: row, 
                                fromCol: col, 
                                toRow: move.row, 
                                toCol: move.col, 
                                capture: move.capture 
                            });
                        }
                    }
                }
            }
            
            // Prioriza capturas se houver
            if (mustCapture) {
                return moves.filter(move => move.capture);
            }
            
            return moves;
        }

        // Movimento da IA
        function aiMove() {
            const maxDepth = difficulty === 'easy' ? 2 : difficulty === 'medium' ? 4 : 6;
            let moves = getAllPossibleMoves('ia');
            
            if (moves.length === 0) {
                const result = checkWin();
                if (result.winner) {
                    document.getElementById('message').textContent = result.winner === 'player' ? 'Você venceu!' : 'A IA venceu!';
                    gameOver = true;
                }
                return;
            }
            
            let bestMove = null;
            let bestValue = -Infinity;
            let chainMoves = [];
            let currentPiece = null;

            const executeMove = (move) => {
                const isCapture = makeMove(move.fromRow, move.fromCol, move.toRow, move.toCol);
                chainMoves.push(move);
                if (isCapture && getValidMoves(move.toRow, move.toCol, true).length > 0) {
                    currentPiece = { row: move.toRow, col: move.toCol };
                } else {
                    currentPiece = null;
                }
                return isCapture;
            };

            for (const move of moves) {
                const tempBoard = board.map(row => row.slice());
                chainMoves = [];
                currentPiece = null;
                const isCapture = executeMove(move);
                let value = minimax(maxDepth - 1, -Infinity, Infinity, false, !!currentPiece, currentPiece);
                board = tempBoard;
                if (value > bestValue) {
                    bestValue = value;
                    bestMove = move;
                }
            }

            if (bestMove) {
                chainMoves = [];
                currentPiece = null;
                const isCapture = executeMove(bestMove);
                drawBoard();
                document.getElementById('message').textContent = isCapture ? 'IA capturou!' : 'Vez da IA...';
                
                if (currentPiece && getValidMoves(currentPiece.row, currentPiece.col, true).length > 0) {
                    setTimeout(aiMove, 500); // Continua capturando
                } else {
                    const result = checkWin();
                    if (result.winner) {
                        document.getElementById('message').textContent = result.winner === 'player' ? 'Você venceu!' : 'A IA venceu!';
                        gameOver = true;
                    } else {
                        currentPlayer = 'player';
                        mustCapture = hasMandatoryCaptures('player');
                        captureChainPiece = null;
                        document.getElementById('message').textContent = mustCapture ? 'Você deve capturar!' : 'Sua vez!';
                    }
                }
            }
        }

        // Verifica vitória
        function checkWin() {
            let playerPieces = 0, iaPieces = 0;
            let playerMoves = 0, iaMoves = 0;
            
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    if (board[row][col]) {
                        const moves = getValidMoves(row, col);
                        if (board[row][col].player === 'player') {
                            playerPieces++;
                            playerMoves += moves.length;
                        } else {
                            iaPieces++;
                            iaMoves += moves.length;
                        }
                    }
                }
            }
            
            if (playerPieces === 0 || playerMoves === 0) return { winner: 'ia' };
            if (iaPieces === 0 || iaMoves === 0) return { winner: 'player' };
            return { winner: null };
        }

        // Manipula cliques no tabuleiro
        canvas.addEventListener('click', (e) => {
            if (currentPlayer !== 'player' || gameOver) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const col = Math.floor(x / cellSize);
            const row = Math.floor(y / cellSize);

            mustCapture = hasMandatoryCaptures('player');

            if (selectedPiece) {
                // Verifica se está em uma cadeia de capturas
                const validPiece = captureChainPiece ? 
                    selectedPiece.row === captureChainPiece.row && selectedPiece.col === captureChainPiece.col : true;
                
                if (!validPiece) {
                    document.getElementById('message').textContent = 'Continue capturando com a mesma peça!';
                    return;
                }

                // Tenta trocar a peça selecionada
                if (board[row][col] && board[row][col].player === 'player' && 
                    !(selectedPiece.row === row && selectedPiece.col === col)) {
                    
                    const moves = getValidMoves(row, col, mustCapture);
                    if (moves.length > 0) {
                        selectedPiece = { row, col };
                        drawBoard();
                        document.getElementById('message').textContent = mustCapture ? 'Peça trocada, você deve capturar!' : 'Peça trocada, selecione o destino!';
                    } else {
                        document.getElementById('message').textContent = 'Nenhum movimento válido para essa peça!';
                    }
                    return;
                }

                // Tenta realizar um movimento
                const moves = getValidMoves(selectedPiece.row, selectedPiece.col, mustCapture || captureChainPiece);
                const move = moves.find(m => m.row === row && m.col === col);
                
                if (move) {
                    const isCapture = makeMove(selectedPiece.row, selectedPiece.col, row, col);
                    drawBoard();
                    
                    if (isCapture && getValidMoves(row, col, true).length > 0) {
                        selectedPiece = { row, col };
                        captureChainPiece = { row, col };
                        document.getElementById('message').textContent = 'Captura realizada, continue se possível!';
                    } else {
                        selectedPiece = null;
                        captureChainPiece = null;
                        const result = checkWin();
                        
                        if (result.winner) {
                            document.getElementById('message').textContent = result.winner === 'player' ? 'Você venceu!' : 'A IA venceu!';
                            gameOver = true;
                        } else {
                            currentPlayer = 'ia';
                            mustCapture = hasMandatoryCaptures('ia');
                            document.getElementById('message').textContent = 'Vez da IA...';
                            setTimeout(aiMove, 500);
                        }
                    }
                } else {
                    document.getElementById('message').textContent = (mustCapture || captureChainPiece) ? 
                        'Você deve capturar uma peça!' : 'Movimento inválido!';
                }
            } else if (board[row][col] && board[row][col].player === 'player') {
                const moves = getValidMoves(row, col, mustCapture);
                if (moves.length > 0) {
                    selectedPiece = { row, col };
                    drawBoard();
                    document.getElementById('message').textContent = mustCapture ? 'Você deve capturar uma peça!' : 'Selecione o destino!';
                } else {
                    document.getElementById('message').textContent = 'Nenhum movimento válido para essa peça!';
                }
            }
        });

        // Inicia o jogo na primeira carga
        startGame();
    </script>
</body>
</html>